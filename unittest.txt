# Create test directories 
mkdir -p tests/unit tests/integration tests/system
# Create Python package files 
touch tests/__init__.py 
touch tests/unit/__init__.py 
touch tests/integration/__init__.py 
touch tests/system/__init__.py 
touch tests/conftest.py

# Create pytest.ini configuration
cat > pytest.ini << 'EOF'
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --tb=short
markers =
    unit: Unit tests
    integration: Integration tests
    system: System tests
    slow: Slow tests
EOF

# Create conftest.py with shared fixtures
cat > tests/conftest.py << 'EOF'
import pytest
import tempfile
import os
from datetime import datetime
from unittest.mock import patch

@pytest.fixture
def temp_db():
    """Create a temporary database for testing."""
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = f.name
    yield db_path
    # Cleanup
    if os.path.exists(db_path):
        os.unlink(db_path)

@pytest.fixture
def sample_license_file():
    """Create temporary license file with test keys."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
        f.write("0000-1111-2222-3333\n1111-2222-3333-4444\n")
        license_path = f.name
    yield license_path
    if os.path.exists(license_path):
        os.unlink(license_path)

@pytest.fixture
def fixed_datetime():
    """Provide a fixed datetime for testing."""
    return datetime(2024, 1, 15, 12, 0, 0
EOF


# Create test for DataStructures
cat > tests/unit/test_datastructures.py << 'EOF'
import pytest
from datetime import datetime
import sys
import os

# Add current directory to Python path
sys.path.insert(0, os.path.abspath('.'))

# We'll use mocking to avoid dependencies
from unittest.mock import Mock, patch, MagicMock

class TestTaskClass:
    """Test the Task class from DataStructures.py"""
    
    def test_task_creation_basic(self):
        """Test creating a Task with minimal parameters."""
        # First, we need to mock the kdb module
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        # Mock the module import
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            # Now import DataStructures
            import DataStructures
            
            # Create a task
            task = DataStructures.Task(
                Title="Test Task",
                Status="To-Do",
                PersonInCharge=1234567890,
                DueDate="2024-12-31",
                Creator=9876543210,
                AdditionalInfo="Test info"
            )
            
            # Verify basic attributes
            assert task.title == "Test Task"
            assert task.Status == "To-Do"
            assert task.PersonInCharge == 1234567890
            assert task.DueDate == "2024-12-31"
            assert task.Creator == 9876543210
            assert task.AdditionalInfo == "Test info"
            assert task.ID is None
            assert isinstance(task.CreationDate, datetime)
    
    def test_task_creation_full(self):
        """Test creating a Task with all parameters."""
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            import DataStructures
            
            fixed_date = datetime(2024, 1, 1, 10, 30, 0)
            task = DataStructures.Task(
                Title="Complete Task",
                Status="In Progress",
                PersonInCharge=1111111111,
                DueDate="2024-06-30",
                Creator=2222222222,
                AdditionalInfo="Important task",
                CreationDate=fixed_date,
                Editors=3333333333,
                ID=42
            )
            
            assert task.title == "Complete Task"
            assert task.Status == "In Progress"
            assert task.PersonInCharge == 1111111111
            assert task.DueDate == "2024-06-30"
            assert task.Creator == 2222222222
            assert task.AdditionalInfo == "Important task"
            assert task.CreationDate == fixed_date
            assert task.Editors == 3333333333
            assert task.ID == 42
    
    def test_format_date_datetime(self):
        """Test FormatDate with datetime object."""
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            import DataStructures
            
            task = DataStructures.Task("Test", "To-Do", 123, "2024-12-31", 456, "Info")
            
            # Test with datetime
            test_dt = datetime(2024, 3, 15, 14, 30, 45)
            result = task.FormatDate(test_dt)
            
            assert result == "2024-03-15 14:30:45"
    
    def test_format_date_string(self):
        """Test FormatDate with string (should return unchanged)."""
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            import DataStructures
            
            task = DataStructures.Task("Test", "To-Do", 123, "2024-12-31", 456, "Info")
            
            # Test with string
            date_string = "2024-03-15"
            result = task.FormatDate(date_string)
            
            assert result == date_string
    
    def test_format_date_other_types(self):
        """Test FormatDate with None and integer."""
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            import DataStructures
            
            task = DataStructures.Task("Test", "To-Do", 123, "2024-12-31", 456, "Info")
            
            # Test with None
            assert task.FormatDate(None) == "None"
            
            # Test with integer
            assert task.FormatDate(12345) == "12345"
    
    def test_str_representation(self):
        """Test the __str__ method."""
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            import DataStructures
            
            fixed_date = datetime(2024, 1, 15, 10, 30, 0)
            task = DataStructures.Task(
                Title="String Test",
                Status="Finished",
                PersonInCharge=1234567890,
                DueDate="2024-12-31",
                Creator=9876543210,
                AdditionalInfo="String test info",
                CreationDate=fixed_date,
                Editors=5555555555,
                ID=7
            )
            
            result = str(task)
            
            # Check string contains all important information
            assert "ID: 7" in result
            assert "Task: String Test" in result
            assert "Status: Finished" in result
            assert "Assigned to: 1234567890" in result
            assert "CreationTime: 2024-01-15 10:30:00" in result
            assert "Due: 2024-12-31" in result
            assert "Created by: 9876543210" in result
            assert "Editors: 5555555555" in result
            assert "Additional Info: String test info" in result
    
    def test_str_representation_no_id(self):
        """Test __str__ method when task has no ID."""
        mock_kdb = Mock()
        mock_kdb.GetUserByPhone = Mock(return_value=["Test User"])
        
        with patch.dict('sys.modules', {'KanbanInfoDatabase': mock_kdb}):
            import DataStructures
            
            task = DataStructures.Task(
                Title="No ID Task",
                Status="To-Do",
                PersonInCharge=1234567890,
                DueDate="2024-12-31",
                Creator=9876543210,
                AdditionalInfo="No ID"
            )
            
            result = str(task)
            
            # Should not contain "ID: None" or "ID: "
            assert "ID:" not in result
            assert "Task: No ID Task" in result
EOF

pytest tests/unit/test_datastructures.py -v

# Create test for Database module
cat > tests/unit/test_database.py << 'EOF'
import pytest
import sys
import os
import bcrypt

sys.path.insert(0, os.path.abspath('.'))

class TestDatabaseFunctions:
    """Test the Database.py module functions."""
    
    def test_hash_password_creates_hash(self):
        """Test that HashPassword creates a valid bcrypt hash."""
        import Database
        
        password = "MySecurePassword123"
        hashed = Database.HashPassword(password)
        
        # Should be a string
        assert isinstance(hashed, str)
        # Should not be the plain password
        assert hashed != password
        # Should be a valid bcrypt hash
        assert bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))
    
    def test_hash_password_different_salts(self):
        """Test that hashing the same password produces different hashes (due to different salts)."""
        import Database
        
        password = "SamePassword"
        hash1 = Database.HashPassword(password)
        hash2 = Database.HashPassword(password)
        
        # Hashes should be different (different salts)
        assert hash1 != hash2
        # But both should verify correctly
        assert bcrypt.checkpw(password.encode('utf-8'), hash1.encode('utf-8'))
        assert bcrypt.checkpw(password.encode('utf-8'), hash2.encode('utf-8'))
    
    def test_verify_password_correct(self):
        """Test VerifyPassword with correct password."""
        import Database
        
        password = "testpassword123"
        hashed = Database.HashPassword(password)
        
        result = Database.VerifyPassword(password, hashed)
        assert result is True
    
    def test_verify_password_incorrect(self):
        """Test VerifyPassword with incorrect password."""
        import Database
        
        password = "correctpassword"
        wrong_password = "wrongpassword"
        hashed = Database.HashPassword(password)
        
        result = Database.VerifyPassword(wrong_password, hashed)
        assert result is False
    
    def test_verify_password_invalid_hash(self):
        """Test VerifyPassword with invalid hash format."""
        import Database
        
        result = Database.VerifyPassword("password", "not-a-valid-hash")
        # Should return False or not crash
        assert result is False
    
    def test_display_data_conversion(self):
        """Test DisplayData converts database row to dictionary."""
        import Database
        
        # Sample database row
        row = (1, 1234567890, "John Doe", 1, "Admin", "hashed_password")
        
        result = Database.DisplayData(row)
        
        assert isinstance(result, dict)
        assert result["ID"] == 1
        assert result["Phone number"] == 1234567890
        assert result["Name"] == "John Doe"
        assert result["Activation status"] == 1
        assert result["Position"] == "Admin"
        assert result["PasswordHash"] == "hashed_password"
    
    def test_display_data_none(self):
        """Test DisplayData with None input."""
        import Database
        
        result = Database.DisplayData(None)
        assert result is None
EOF

pytest tests/unit/test_database.py -v

# Create test file for License.py
cat > tests/unit/test_license.py << 'EOF'
import pytest
import sys
import os
from unittest.mock import patch, mock_open, MagicMock
from pathlib import Path

# Add current directory to Python path
sys.path.insert(0, os.path.abspath('.'))

class TestLicenseFileOperations:
    """Test file operations in License.py"""
    
    def test_load_license_keys_file_exists_with_keys(self, tmp_path):
        """Test LoadLicenseKeys when file exists and has keys."""
        # Create a temporary license file
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("# Comment line\n0000-1111-2222-3333\n\n1111-2222-3333-4444\n# Another comment")
        
        # Mock the LICENSE_FILE path
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            keys = License.LoadLicenseKeys()
            
            # Should return a list of keys (not None)
            assert keys is not None
            # Should have 2 valid keys
            assert len(keys) == 2
            # Should contain both keys
            assert "0000-1111-2222-3333" in keys
            assert "1111-2222-3333-4444" in keys
            # Should not contain comments or empty lines
            assert "# Comment line" not in keys
            assert "" not in keys
    
    def test_load_license_keys_file_exists_empty(self, tmp_path):
        """Test LoadLicenseKeys when file exists but is empty or only has comments."""
        # Create empty license file
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("# Only comments\n\n  \n# More comments")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            keys = License.LoadLicenseKeys()
            
            # Should return empty list
            assert keys == []
    
    def test_load_license_keys_file_not_exists(self, tmp_path):
        """Test LoadLicenseKeys when file doesn't exist."""
        # Create a non-existent file path
        non_existent_file = tmp_path / "non_existent.txt"
        
        with patch('License.LICENSE_FILE', non_existent_file):
            import License
            
            keys = License.LoadLicenseKeys()
            
            # Should return None when file doesn't exist
            assert keys is None
    
    def test_load_license_keys_file_with_whitespace(self, tmp_path):
        """Test LoadLicenseKeys handles whitespace correctly."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("  0000-1111-2222-3333  \n  1111-2222-3333-4444  \n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            keys = License.LoadLicenseKeys()
            
            # Should strip whitespace
            assert "0000-1111-2222-3333" in keys
            assert "1111-2222-3333-4444" in keys
            # Should not have leading/trailing spaces
            for key in keys:
                assert key == key.strip()

class TestLicenseValidationLogic:
    """Test validation logic in License.py"""
    
    def test_validate_license_exact_match(self, tmp_path):
        """Test ValidateLicense with exact key match."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n1111-2222-3333-4444\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Exact match should return True
            result = License.ValidateLicense("0000-1111-2222-3333")
            assert result is True
            
            result = License.ValidateLicense("1111-2222-3333-4444")
            assert result is True
    
    def test_validate_license_invalid_key(self, tmp_path):
        """Test ValidateLicense with invalid/non-existent key."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n1111-2222-3333-4444\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Invalid key should return False
            result = License.ValidateLicense("9999-9999-9999-9999")
            assert result is False
            
            # Similar but not exact match
            result = License.ValidateLicense("0000-1111-2222-3334")
            assert result is False
    
    def test_validate_license_none_input(self, tmp_path):
        """Test ValidateLicense with None input."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # None input should return False
            result = License.ValidateLicense(None)
            assert result is False
    
    def test_validate_license_empty_string(self, tmp_path):
        """Test ValidateLicense with empty string."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Empty string should return False
            result = License.ValidateLicense("")
            assert result is False
    
    def test_validate_license_case_sensitive(self, tmp_path):
        """Test ValidateLicense is case-sensitive."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("ABCD-EFGH-IJKL-MNOP\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Should be case-sensitive
            result = License.ValidateLicense("ABCD-EFGH-IJKL-MNOP")
            assert result is True
            
            result = License.ValidateLicense("abcd-efgh-ijkl-mnop")
            assert result is False

class TestLicenseUserInteraction:
    """Test user interaction in License.py"""
    
    @patch('builtins.input')
    def test_license_input_success_first_try(self, mock_input, tmp_path):
        """Test LicenseInput succeeds on first attempt."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n1111-2222-3333-4444\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Mock input to return valid key
            mock_input.return_value = "0000-1111-2222-3333"
            
            result = License.LicenseInput()
            
            # Should return True
            assert result is True
            # Input should be called once
            mock_input.assert_called_once_with("Enter license key: ")
    
    @patch('builtins.input')
    def test_license_input_three_failures_then_success(self, mock_input, tmp_path):
        """Test LicenseInput with failures then success."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Mock input: two wrong keys, then correct key
            mock_input.side_effect = ["wrong-key-1", "wrong-key-2", "0000-1111-2222-3333"]
            
            result = License.LicenseInput()
            
            # Should return True (succeeded on 3rd try)
            assert result is True
            # Input should be called 3 times
            assert mock_input.call_count == 3
    
    @patch('builtins.input')
    def test_license_input_three_failures_then_fail(self, mock_input, tmp_path):
        """Test LicenseInput with 3 failures."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Mock input: three wrong keys
            mock_input.side_effect = ["wrong-key-1", "wrong-key-2", "wrong-key-3"]
            
            result = License.LicenseInput()
            
            # Should return False (all 3 attempts failed)
            assert result is False
            # Input should be called exactly 3 times
            assert mock_input.call_count == 3
    
    @patch('builtins.input')
    def test_license_input_whitespace_handling(self, mock_input, tmp_path):
        """Test LicenseInput handles whitespace in input."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Mock input with whitespace
            mock_input.return_value = "  0000-1111-2222-3333  "
            
            result = License.LicenseInput()
            
            # Should return True (whitespace should be stripped)
            assert result is True

# Test integration between functions
class TestLicenseIntegration:
    """Test integration between License.py functions."""
    
    @patch('builtins.input')
    def test_full_license_flow(self, mock_input, tmp_path):
        """Test complete license flow."""
        license_file = tmp_path / "license_keys.txt"
        license_file.write_text("0000-1111-2222-3333\n1111-2222-3333-4444\n")
        
        with patch('License.LICENSE_FILE', license_file):
            import License
            
            # Test 1: Direct validation
            assert License.ValidateLicense("0000-1111-2222-3333") is True
            assert License.ValidateLicense("9999-9999-9999-9999") is False
            
            # Test 2: Load keys
            keys = License.LoadLicenseKeys()
            assert keys is not None
            assert len(keys) == 2
            
            # Test 3: User input flow
            mock_input.return_value = "0000-1111-2222-3333"
            assert License.LicenseInput() is True
EOF

pytest tests/unit/test_license.py -v

# Create test file for Notification.py
cat > tests/unit/test_notification.py << 'EOF'
import pytest
import sys
import os
from datetime import datetime, timedelta
from unittest.mock import patch, MagicMock, call

# Add current directory to Python path
sys.path.insert(0, os.path.abspath('.'))

class TestNotificationDateLogic:
    """Test date logic in Notification.py"""
    
    def test_no_kanban_table(self):
        """Test when KANBAN table doesn't exist."""
        with patch('Notification.datetime') as mock_dt, \
             patch('Notification.sqlite3') as mock_sqlite3:
            
            mock_now = datetime(2024, 1, 15, 12, 0, 0)
            mock_dt.now.return_value = mock_now
            
            # Mock database connection
            mock_conn = MagicMock()
            mock_cursor = MagicMock()
            mock_sqlite3.connect.return_value = mock_conn
            mock_conn.execute.return_value = mock_cursor
            
            # Mock that KANBAN table doesn't exist
            mock_cursor.fetchone.return_value = None
            
            import Notification
            
            notifications = Notification.UpcomingTask()
            
            # Should return empty list when table doesn't exist
            assert notifications == []

    
    def test_empty_due_date_handling(self):
        """Test handling of empty or None due dates."""
        with patch('Notification.datetime') as mock_dt, \
             patch('Notification.sqlite3') as mock_sqlite3, \
             patch('Notification.kdb') as mock_kdb:
            
            mock_now = datetime(2024, 1, 15, 12, 0, 0)
            mock_dt.now.return_value = mock_now
            
            # Mock database
            mock_conn = MagicMock()
            mock_cursor = MagicMock()
            mock_sqlite3.connect.return_value = mock_conn
            mock_conn.execute.return_value = mock_cursor
            mock_cursor.fetchone.return_value = ('KANBAN',)
            
            # Task with empty due date
            test_tasks = [
                (1, "Empty Date Task", "To-Do", 1234567890, "2024-01-15 10:00:00", "", 9876543210, None, "Info"),
                (2, "Whitespace Date Task", "To-Do", 1234567890, "2024-01-15 10:00:00", "   ", 9876543210, None, "Info"),
            ]
            mock_cursor.fetchall.return_value = test_tasks
            
            import Notification
            
            notifications = Notification.UpcomingTask()
            
            # Should skip tasks with empty/whitespace due dates
            notifications_str = "".join(notifications)
            assert "Empty Date Task" not in notifications_str
            assert "Whitespace Date Task" not in notifications_str

class TestPrintNotification:
    """Test PrintNotification function."""
    
    @patch('builtins.print')
    def test_print_notification_with_tasks(self, mock_print):
        """Test PrintNotification with tasks."""
        with patch('Notification.UpcomingTask') as mock_upcoming:
            # Mock returning notifications
            mock_upcoming.return_value = [
                "\n" + "-"*50 + "\n",
                "[Task due in 2d 06h 30m]\nTask details...\n",
                "\n" + "-"*50 + "\n"
            ]
            
            import Notification
            
            Notification.PrintNotification()
            
            # Should call print for each notification line
            assert mock_print.call_count >= 3
    
    @patch('builtins.print')
    def test_print_notification_none(self, mock_print):
        """Test PrintNotification when UpcomingTask returns None."""
        with patch('Notification.UpcomingTask') as mock_upcoming:
            mock_upcoming.return_value = None
            
            import Notification
            
            Notification.PrintNotification()
            
            # Should not print anything
            mock_print.assert_not_called()
    
    @patch('builtins.print')
    def test_print_notification_empty(self, mock_print):
        """Test PrintNotification with empty notifications."""
        with patch('Notification.UpcomingTask') as mock_upcoming:
            mock_upcoming.return_value = []
            
            import Notification
            
            Notification.PrintNotification()
            
            # Should still print (but might print nothing or just separators)
            # At minimum, it won't crash

# Test the Due constant
def test_due_constant():
    """Test that Due constant is set correctly."""
    import Notification
    # Should be 14 as per the image
    assert Notification.Due == 14
EOF

pytest tests/unit/test_notification.py -v

# Create test file for CLI.py
cat > tests/unit/test_cli.py << 'EOF'
import pytest
import sys
import os
from datetime import datetime, date
from unittest.mock import patch, MagicMock, call

# Add current directory to Python path
sys.path.insert(0, os.path.abspath('.'))

class TestHandleStatusInput:
    """Test HandleStatusInput function."""
    
    @patch('builtins.input')
    def test_handle_status_input_conversion_valid(self, mock_input):
        """Test status input conversion (1->To-Do, 2->In Progress, etc.)."""
        import CLI
        
        test_cases = [
            ("1", "To-Do"),
            ("2", "In Progress"),
            ("3", "Waiting Review"),
            ("4", "Finished"),
        ]
        
        for input_val, expected in test_cases:
            mock_input.return_value = input_val
            
            result = CLI.HandleStatusInput(Mandatory=True)
            
            assert result == expected, f"Input {input_val} should return {expected}"
    
    @patch('builtins.input')
    def test_handle_status_input_invalid_then_valid(self, mock_input):
        """Test invalid input then valid input."""
        import CLI
        
        # First invalid, then valid
        mock_input.side_effect = ["5", "2"]  # 5 is invalid, 2 is valid
        
        result = CLI.HandleStatusInput(Mandatory=True)
        
        # Should return "In Progress" (from input "2")
        assert result == "In Progress"
        # Should be called twice
        assert mock_input.call_count == 2
    
    @patch('builtins.input')
    def test_handle_status_input_non_numeric(self, mock_input):
        """Test non-numeric input."""
        import CLI
        
        mock_input.side_effect = ["abc", "3"]
        
        result = CLI.HandleStatusInput(Mandatory=True)
        
        assert result == "Waiting Review"  # From input "3"
        assert mock_input.call_count == 2
    
    @patch('builtins.input')
    def test_handle_status_input_empty_not_mandatory(self, mock_input):
        """Test empty input when not mandatory."""
        import CLI
        
        mock_input.return_value = ""
        
        result = CLI.HandleStatusInput(Mandatory=False)
        
        # Should return None when not mandatory and empty
        assert result is None
    
    @patch('builtins.input')
    def test_handle_status_input_empty_mandatory(self, mock_input):
        """Test empty input when mandatory."""
        import CLI
        
        mock_input.side_effect = ["", "1"]  # Empty, then valid
        
        result = CLI.HandleStatusInput(Mandatory=True)
        
        assert result == "To-Do"  # From input "1"
        assert mock_input.call_count == 2
    
    @patch('builtins.input')
    def test_handle_status_input_additional_text(self, mock_input, capsys):
        """Test status input with additional text in prompt."""
        import CLI
        
        mock_input.return_value = "2"
        
        result = CLI.HandleStatusInput(Mandatory=True, AdditionalText="Blank: Cancel")
        
        # Should work correctly
        assert result == "In Progress"
        
        # Check that additional text appears in prompt
        output = capsys.readouterr().out
        # The prompt should contain the additional text
        # Note: This might not capture the input prompt, but we can verify the function works

class TestHandleDueDateInput:
    """Test HandleDueDateInput function."""

    @patch('builtins.input')
    def test_handle_due_date_input_empty_not_mandatory(self, mock_input):
        """Test empty due date when not mandatory."""
        import CLI
        
        mock_input.return_value = ""
        
        result = CLI.HandleDueDateInput(Mandatory=False, DefaultResponse="Undecided")
        
        assert result == "Undecided"
    

class TestHandleUserInputFunctions:
    """Test HandlePersonInChargeInput, HandleCreatorInput, HandleEditorInput."""
    
    @patch('builtins.input')
    def test_handle_person_in_charge_input_user_exists(self, mock_input):
        """Test person in charge input with existing user."""
        import CLI
        
        with patch('CLI.kdb') as mock_kdb:
            # Mock user exists
            mock_kdb.CheckUserExist.return_value = True
            mock_kdb.GetUserByPhone.return_value = ["John Doe"]
            
            mock_input.return_value = "1234567890"
            
            result = CLI.HandlePersonInChargeInput(Mandatory=True)
            
            assert result == 1234567890
            mock_kdb.CheckUserExist.assert_called_with(1234567890)
    
    @patch('builtins.input')
    def test_handle_person_in_charge_input_user_not_exists(self, mock_input):
        """Test person in charge input with non-existent user."""
        import CLI
        
        with patch('CLI.kdb') as mock_kdb:
            # Mock user doesn't exist, then exists
            mock_kdb.CheckUserExist.side_effect = [False, True]
            mock_kdb.GetUserByPhone.return_value = ["John Doe"]
            
            mock_input.side_effect = ["1111111111", "1234567890"]
            
            result = CLI.HandlePersonInChargeInput(Mandatory=True)
            
            assert result == 1234567890
            assert mock_input.call_count == 2
            assert mock_kdb.CheckUserExist.call_count == 2
    
    @patch('builtins.input')
    def test_handle_person_in_charge_input_empty_not_mandatory(self, mock_input):
        """Test empty person in charge when not mandatory."""
        import CLI
        
        mock_input.return_value = ""
        
        result = CLI.HandlePersonInChargeInput(Mandatory=False, DefaultResponse="Undecided")
        
        assert result == "Undecided"
    
    @patch('builtins.input')
    def test_handle_person_in_charge_input_invalid_number(self, mock_input):
        """Test invalid phone number input."""
        import CLI
        
        with patch('CLI.kdb') as mock_kdb:
            mock_kdb.CheckUserExist.return_value = True
            mock_kdb.GetUserByPhone.return_value = ["John Doe"]
            
            # Non-numeric, then valid
            mock_input.side_effect = ["not-a-number", "1234567890"]
            
            result = CLI.HandlePersonInChargeInput(Mandatory=True)
            
            assert result == 1234567890
            assert mock_input.call_count == 2
    
    @patch('builtins.input')
    def test_handle_creator_input_similar(self, mock_input):
        """Test HandleCreatorInput (similar to person in charge)."""
        import CLI
        
        with patch('CLI.kdb') as mock_kdb:
            mock_kdb.CheckUserExist.return_value = True
            mock_kdb.GetUserByPhone.return_value = ["Jane Smith"]
            
            mock_input.return_value = "9876543210"
            
            result = CLI.HandleCreatorInput(Mandatory=True)
            
            assert result == 9876543210
    
    @patch('builtins.input')
    def test_handle_editor_input_similar(self, mock_input):
        """Test HandleEditorInput (similar to other user inputs)."""
        import CLI
        
        with patch('CLI.kdb') as mock_kdb:
            mock_kdb.CheckUserExist.return_value = True
            mock_kdb.GetUserByPhone.return_value = ["Editor Name"]
            
            mock_input.return_value = "5555555555"
            
            result = CLI.HandleEditorInput(Mandatory=True)
            
            assert result == 5555555555

class TestMandatoryOptionalHandling:
    """Test mandatory vs optional field handling."""
    
    @patch('builtins.input')
    def test_optional_field_empty_returns_default(self, mock_input):
        """Test that optional fields return default when empty."""
        import CLI
        
        # Test with HandlePersonInChargeInput
        mock_input.return_value = ""
        
        result = CLI.HandlePersonInChargeInput(Mandatory=False, DefaultResponse="Undecided")
        
        assert result == "Undecided"
        # Should not check user existence for empty optional field
        # (The mock would fail if it tried)
    
    @patch('builtins.input')
    def test_status_input_mandatory_vs_optional(self, mock_input):
        """Test status input mandatory vs optional behavior."""
        import CLI
        
        # Test optional with empty
        mock_input.return_value = ""
        result = CLI.HandleStatusInput(Mandatory=False)
        assert result is None
        
        # Test mandatory with empty then valid
        mock_input.side_effect = ["", "1"]
        result = CLI.HandleStatusInput(Mandatory=True)
        assert result == "To-Do"
EOF

pytest tests/unit/test_cli.py -v
